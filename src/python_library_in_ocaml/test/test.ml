open Base
open Stdio
open Python_library_in_ocaml

type enum = A | B [@@deriving python, python_export_type]

type simple_alias = int * (string * float)
[@@deriving python, python_export_type]

type sum_type = C of bool * string | D of enum
[@@deriving python, python_export_type]

type type_with_lists = L of int option list
[@@deriving python, python_export_type]

type record_type = {x: int; y: float option}
[@@deriving python, python_export_type]

type ('a, 'b) polymorphic = {x: 'a; y: 'b}
[@@deriving python, python_export_type]

let%python_export f (x : int) : int = x + 1

let%python_export rec fact (n : int) : int =
  if n <= 0 then 1 else n * fact (n - 1)

let%python_docstring sum = "Sum a list of numbers."

let%python_export sum (l : int list) : int = List.fold_left ~f:( + ) ~init:0 l

let%python_export make_record (x : int) : record_type = {x; y= None}

let%test_unit "functions preserved" =
  assert (f 5 = 6) ;
  assert (fact 3 = 6) ;
  assert (sum [1; 2; 3] = 6)

let%test_unit "docstrings" =
  assert (
    [%equal: string option]
      (registered_python_docstring "sum")
      (Some "Sum a list of numbers.") )

let%expect_test "registered types" =
  List.iter (registered_python_types ()) ~f:(fun v ->
      printf !"%{sexp: python_type_declaration}\n\n" v ) ;
  [%expect
    {|
    ((type_name Enum) (type_vars ())
     (definition
      (Py_Alias
       (Py_Union
        ((Py_Tuple ((Py_Literal A) (Py_Atomic Py_None)))
         (Py_Tuple ((Py_Literal B) (Py_Atomic Py_None))))))))

    ((type_name SimpleAlias) (type_vars ())
     (definition
      (Py_Alias
       (Py_Tuple
        ((Py_Atomic Py_Int)
         (Py_Tuple ((Py_Atomic Py_String) (Py_Atomic Py_Float))))))))

    ((type_name SumType) (type_vars ())
     (definition
      (Py_Alias
       (Py_Union
        ((Py_Tuple
          ((Py_Literal C) (Py_Tuple ((Py_Atomic Py_Bool) (Py_Atomic Py_String)))))
         (Py_Tuple ((Py_Literal D) (Py_Tuple ((Py_Atomic (Py_Custom Enum)))))))))))

    ((type_name TypeWithLists) (type_vars ())
     (definition
      (Py_Alias
       (Py_Union
        ((Py_Tuple
          ((Py_Literal L)
           (Py_Tuple
            ((Py_List (Py_Union ((Py_Atomic Py_Int) (Py_Atomic Py_None)))))))))))))

    ((type_name RecordType) (type_vars ())
     (definition
      (Py_TypedDict
       ((x (Py_Atomic Py_Int))
        (y (Py_Union ((Py_Atomic Py_Float) (Py_Atomic Py_None))))))))

    ((type_name Polymorphic) (type_vars (A B))
     (definition (Py_TypedDict ((x (Py_Var A)) (y (Py_Var B)))))) |}]

let%expect_test "registered values" =
  List.iter (registered_python_values ()) ~f:(fun v ->
      printf !"%{sexp: python_value}\n\n" v ) ;
  [%expect
    {|
    ((pyobject <opaque>) (name f) (doc "")
     (signature
      (Py_Function (args ((x (Py_Atomic Py_Int)))) (ret (Py_Atomic Py_Int)))))

    ((pyobject <opaque>) (name fact) (doc "")
     (signature
      (Py_Function (args ((n (Py_Atomic Py_Int)))) (ret (Py_Atomic Py_Int)))))

    ((pyobject <opaque>) (name sum) (doc "")
     (signature
      (Py_Function (args ((l (Py_List (Py_Atomic Py_Int)))))
       (ret (Py_Atomic Py_Int)))))

    ((pyobject <opaque>) (name make_record) (doc "")
     (signature
      (Py_Function (args ((x (Py_Atomic Py_Int))))
       (ret (Py_Atomic (Py_Custom RecordType)))))) |}]

let%expect_test "pyi stub" =
  let values = registered_python_values () in
  let types = registered_python_types () in
  print_endline (Stubs.generate_pyi_stub ~values ~types) ;
  [%expect {|
    # Autogenerated by python_library_in_ocaml

    from typing import TypeAlias, TypedDict, Literal, TypeVar

    A = TypeVar("A")

    B = TypeVar("B")

    Enum: TypeAlias = tuple[Literal["A"], None] | tuple[Literal["B"], None]

    SimpleAlias: TypeAlias = tuple[int, tuple[str, float]]

    SumType: TypeAlias = tuple[Literal["C"], tuple[bool, str]] | tuple[Literal["D"], tuple["Enum"]]

    TypeWithLists: TypeAlias = tuple[Literal["L"], tuple[list[int | None]]]

    class RecordType(TypedDict, total=True):
        x: int
        y: float | None

    class Polymorphic(TypedDict, Generic[A, B], total=True):
        x: A
        y: B

    def f(x: int) -> int:
        ...

    def fact(n: int) -> int:
        ...

    def sum(l: list[int]) -> int:
        """
        Sum a list of numbers.
        """
        ...

    def make_record(x: int) -> "RecordType":
        ... |}]
